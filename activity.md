Для создания детального журнала активности, похожего на Jira, можно использовать архитектуру, в которой backend пишет события в таблицу `Activities` с типом события, ключом локализации и метаданными, а frontend строит текст с помощью i18n‑словаря.  Каждое событие имеет свой тип (логин пользователя, запуск теста, создание проекта и т. д.), а сообщение формируется через шаблон из словаря, подставляя значения из `metadata`.  Backend предоставляет API для трёх вариантов: глобальная активность (главная), активность проекта и активность конкретного пользователя; события доставляются по WebSockets/SignalR в реальном времени.  Такая архитектура соответствует лучшим практикам: хранить переводы отдельно и использовать таблицу локализации, а для масштабирования использовать очередь сообщений и микросервисы.

---

### Подробный разбор и предлагаемое решение

#### 1. Общие требования

* **Разделение ленты активности**: главная страница показывает события по всем проектам, страница проекта — только события этого проекта, страница пользователя — только действия конкретного пользователя.
* **Локализация**: текст событий должен автоматически отображаться на выбранном языке; переводимый текст и динамические данные (имя пользователя, название проекта) должны быть разделены.
* **Расширяемость**: добавление новых типов событий не должно менять существующий код; достаточно добавить запись в словарь локализации и новую константу типа.

#### 2. Структура базы данных

1. **Таблица Activities**. В существующем коде уже есть сущность `Activity` с полями `Type`, `Message`, `ProjectId`, `UserId`, `Metadata`. Чтобы обеспечить локализацию и гибкость, предлагаю модифицировать её:

   * `EventType` – строка/enum, определяет тип события (например, `UserLoggedIn`, `ProjectCreated`, `TestRunStarted`).
   * `MessageKey` – ключ шаблона (может совпадать с `EventType`), чтобы можно было различать подтипы (например, `UserLogin.Success`, `UserLogin.Logout`).
   * `Metadata` – JSON‑поле с динамическими данными (имя пользователя, идентификатор тест‑рана, длительность, количество ошибок и т. п.).
   * `ProjectId`, `UserId`, `Timestamp` – оставить, как в текущей схеме.
   * `ActorId` (кто совершил действие) и `TargetUserId` (если действие направлено на другого пользователя) — при необходимости.

2. **Субсхема локализации**. Статья о проектировании мультиязычных БД советует вынести все переводимые строки в отдельную схему, используя таблицу языков, таблицу исходных текстов и таблицу переводов. В нашем случае переводимые строки могут храниться во фронтенде в JSON‑файлах, поэтому в БД достаточно хранить ключ `MessageKey`. Если потребуется локализация на сервере (например, при отправке email‑уведомлений), можно завести таблицы:

   * `Languages` (идентификатор и название языка).
   * `TextResources` (MessageKey, оригинальный текст).
   * `TextTranslations` (TextResourceId, LanguageId, Translation, описание placeholders).

#### 3. Backend‑службы

1. **Логирование событий**. В различных сервисах (проекты, тест‑раны, пользователи) при наступлении события вызывается метод сервиса `ActivityService.CreateActivityAsync`, который записывает событие в БД. Уже существующий сервис умеет это делать. В новой версии вместо хранения готового текста мы передаём:

   ```csharp
   await activityService.CreateActivityAsync(
       EventType.UserLoggedIn,
       messageKey: "Activity.UserLoggedIn",
       projectId: null,
       userId: userId,
       metadata: JsonSerializer.Serialize(new { userName = currentUser.Name }));
   ```

   Список возможных `EventType` и `MessageKey` хранится в отдельном static‑классе (например, `ActivityKeys`), что упрощает добавление новых типов.

2. **API‑эндпоинты**. Существующий `ActivityController` уже реализует:

   * `/api/v1/activity` — глобальная лента с фильтрами.
   * `/api/v1/activity/projects/{projectId}` — события конкретного проекта.
   * `/api/v1/activity/global` — глобальные события для пользователя.
   * Добавляем `/api/v1/activity/users/{userId}` для ленты конкретного пользователя.
     Эти методы используют `ActivityService` для выборки данных и возвращают массив объектов `{ timestamp, eventType, messageKey, metadata, projectId, userId }`.

3. **Реальное время**. Для доставки событий на клиент можно использовать SignalR (уже используется) или WebSockets. Сервис публикует событие в канал `ActivityGlobal`, `ActivityProject_{projectId}` или `ActivityUser_{userId}`; фронтенд подписывается на нужные каналы.

4. **Асинхронность и масштабирование**. В будущих версиях можно выделить отдельный микросервис «Activity» и отправлять события через очередь (Kafka, RabbitMQ). Практики проектирования ленты новостей рекомендуют использовать очередь сообщений для фан-аута событий, обработки взаимодействий и уведомлений; микросервисная архитектура упрощает масштабирование и изоляцию.

#### 4. Frontend‑слой

1. **Компонент ActivityFeed**. В текущей реализации `ActivityFeed.tsx` загружает события через REST, подписывается на SignalR и выводит готовое сообщение. Чтобы поддержать многоязычность, заменяем хранение `message` на `messageKey` и `metadata`. Компонент получает от сервера такие поля и строит текст через i18n:

   ```typescript
   const { t } = useI18n();
   const renderMessage = (item: ActivityItem) => {
     const metadata = item.metadata ? JSON.parse(item.metadata) : {};
     return t(`activity.${item.messageKey}`, metadata);
   };
   ```

   Структура строк в файлах локализации (`src/locales/ru/activity.json` и `src/locales/en/activity.json`) может быть такой:

   ```json
   {
     "UserLoggedIn": "{{userName}} вошёл в систему",
     "UserLoggedOut": "{{userName}} вышел из системы",
     "TestRunStarted": "Запущен тест‑ран {{testName}} в проекте {{projectName}}",
     "TestRunFinished": "Тест‑ран {{testName}} завершён: ошибок — {{errors}}, успешных тестов — {{passed}}"
   }
   ```

   Такие шаблоны позволяют легко расширять список действий и добавлять новые языки (просто добавив ключи в соответствующий файл).

2. **Разделение ленты**. Компонент принимает параметры `projectId` и `userId`.

   * **Главная страница** — передаём только `since`, получаем глобальные события (без `projectId` и `userId`).
   * **Страница проекта** — передаём `projectId`, получаем события проекта.
   * **Страница пользователя** — передаём `userId`, получаем события пользователя.

   Фронтенд может также фильтровать события по `EventType`, использовав соответствующие иконки и цвета (как в current `ActivityFeed`).

3. **Локализация даты/времени**. Функция `formatTime` уже показывает, как выводить «сегодня», «вчера», «X дней назад» с учётом языка пользователя. Это можно расширить, вынеся строки в локаль (`activity.today`, `activity.yesterday`, `activity.day`, `activity.days2to4`, `activity.days5plus`, `activity.daysAgo`) и используя `Intl.DateTimeFormat` для форматов.

4. **UI и доступность**. Существующий компонент ActivityFeed уже использует шаблон shadcn/ui с современными стилями и анимациями. Для улучшения доступности (A11y) добавлены aria‑атрибуты, роли и сообщения для скрин‑ридеров в документе `TASKS_AND_BACKLOG.md`; это следует сохранить.

#### 5. Примеры типов событий

Чтобы сделать ленту информативной, нужно определить набор типов и соответствующих ключей:

| Категория    | Тип (`EventType`)  | Ключ (`MessageKey`) | Метаданные                               |
| ------------ | ------------------ | ------------------- | ---------------------------------------- |
| Пользователь | `UserLoggedIn`     | `UserLoggedIn`      | `{ userName }`                           |
|              | `UserLoggedOut`    | `UserLoggedOut`     | `{ userName }`                           |
|              | `UserRegistered`   | `UserRegistered`    | `{ userName }`                           |
| Проект       | `ProjectCreated`   | `ProjectCreated`    | `{ projectName, createdBy }`             |
|              | `ProjectUpdated`   | `ProjectUpdated`    | `{ projectName, updatedBy }`             |
| Тест‑ран     | `TestRunStarted`   | `TestRunStarted`    | `{ testName, projectName }`              |
|              | `TestRunFinished`  | `TestRunFinished`   | `{ testName, passed, failed, duration }` |
| Сценарий     | `ScenarioAdded`    | `ScenarioAdded`     | `{ scenarioName, projectName }`          |
| Контейнер    | `ContainerCreated` | `ContainerCreated`  | `{ containerName }`                      |
| Система      | `SystemError`      | `SystemError`       | `{ errorMessage }`                       |

Добавить новый тип — значит добавить новую константу и шаблон в файлы локализации.

#### 6. Расширение на несколько языков

Для каждого поддерживаемого языка создаётся отдельный файл локали. Благодаря тому, что данные о событиях состоят из ключа и метаданных, добавление языка сводится к созданию нового JSON-файла с переводами. Кроме того, статья по проектированию мультиязычной БД подчёркивает, что переводимые тексты лучше хранить отдельно и привязывать их по ключу, чтобы добавление нового языка не затрагивало код. Этот подход будет легко расширяемым и позволит внешним переводчикам работать над файлом локализации без вмешательства в код.

#### 7. Масштабирование и надёжность

Если количество событий вырастет, полезно придерживаться лучших практик лент новостей и распределённых систем:

* **Сообщения в очередь**: для асинхронной записи и fan‑out событий использовать Kafka, RabbitMQ или аналогичные очереди. Это позволяет логирующим сервисам не блокироваться на записи, а лента активности читается с консюмера.
* **Микросервисная архитектура**: разделение на сервисы (User, Project, TestRun, Activity) упрощает масштабирование, повышает отказоустойчивость и улучшает скорость разработки.
* **Кеширование**: для главной ленты можно кешировать последние N событий в Redis; устаревшие данные удаляются по TTL.
* **Мониторинг**: включить логирование ошибок и мониторинг задержек при генерации и доставке событий.

---

### Заключение

Предложенная архитектура позволяет реализовать ленту активности, подобную Jira, сохраняя чистоту кода и поддерживая многоязычность. Хранение ключей и метаданных в БД, применение i18n‑словарей на фронтенде и использование SignalR для реального времени обеспечивают гибкость и расширяемость. Следуя лучшим практикам по локализации и дизайну системы (вынос переводов в отдельные таблицы или файлы, использование очередей и микросервисов), AutoTestKit сможет масштабироваться по мере роста проекта и легко добавлять новые функции в будущих релизах.
